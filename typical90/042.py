def LI(): return list(map(int, input().split()))
MOD = 10 ** 9 + 7

import sys
sys.setrecursionlimit(10 ** 9)

'''
思ったこと
Xは9の倍数→各桁の数を足した数が9の倍数 あまりで判定．
和がKで，Kが9の倍数じゃなかったらそもそも終わり．

もしKが9の倍数ならば和が9になる，1~9のパーミュテーションを求めればOK.
ただ，これをどう求めるか．

使う整数の数に関する制約がない．
→ 漸化式みたいに1から順番に求めていく？
(1): x
(2): (1)+(1)
(3): (2)+(1)

これだと重複を防げない．しかも1~9までと10以上で場合わけが必要．
そんな回答になることが想像できない．

1~9というのが唯一の制限だと思うからこれを使う気がする．

先に超長いリスト作って，リストの中で組み合わせを数え上げる？
→答えが10**9を超えるようなら無理では？

10!で解ける？確率の木を書くイメージ
9の数を固定，8の数を固定...1の数を固定．
9の数を一つ減らしてみる，8の数を固定...


ここで解説をみる．
解説: https://twitter.com/e869120/status/1394423616805097477

ググってる感じDPっぽかったけどどうしてDPなのかがわからず，諦めて回答をみたらDPだった．
なんでDPなのか，わかっていないことはこの問題の意図とは違いそうでちょっと悲しい．

なんでDPなのかと疑問に思ったかというと，どこにその数字をいれるか，（dp[i] = dp[i-1] + xxxだとして，xxxを求めるのがとてもむずかしくないか，）と思った．
言われてみればすべて先頭にappendしていくとすれば重複なくできるよ，っと言われて理解はした．
ただ，正直納得はいっていないので，これだけで解けるようにはたぶんならない．

Python: 52 ms
PyPy: 63 ms
'''

# https://atcoder.jp/contests/typical90/tasks/typical90_ap
def solve_dp(K):
    # dp = [1 for _ in range(K+1)]
    dp = [1] * (K+1)
    for i in range(1, K):
        if i-9 >= 0:
            dp[i+1] = (2*dp[i] - dp[i-9]) % MOD
        else:
            dp[i+1] = (2*dp[i]) % MOD
    return dp[K]
    

def main(*args):
    K, = args

    temp = 0
    for k in str(K):
        temp += int(k)
    # 正直別に直でK%9でもよかった．
    if temp % 9 == 0:
        ans = solve_dp(K) % MOD
    else:
        ans = 0
    print(ans)

if __name__ == '__main__':
    K = int(input())
    main(K)
